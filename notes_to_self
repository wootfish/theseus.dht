what we want is something that can run a live net test

this requires the ability to establish Noise channels

among other things, this requires full setup of Noise crypto, including the preambled public key for the K party in the NK handshake

where would the noise protocol be configured from?

we would ultimately decide what config params we want inside of dispatcher.makeCnxn (for outgoing) or dispatcher.buildProtocol (for incoming) (?)
    (or would it be buildProtoocl in both cases? probably it would be, since both listening and connecting use self as their factory (which is also a mistake, they should be using self.client_factory and self.server_factory))

the dispatcher should be tracking remote public keys and also (via the parent node) the local private node key, and it could probably figure out how to handle chunking too

if the dispatcher delegates its factory-ing to NoiseFactories, then maybe these should do the configuration
    this would make a lot of sense
    if we do it this way, the NoiseFactories need to know everything they need to know to set up configs right
    we could give them configfactories (lol)
    or we could just make the config invariant and
      - pass it in, or
      - have it assembled in __init__ by the NoiseFactory based on info it pulls from a passed-in reference to e.g. the dispatcher or node

config needs to handle handshake type (NN, NK, KN, KK), any PSK, prologued 'K' public keys, and message chunk method
    for chunking: provide a coroutine? or give the config a method backed by whatever private state in the config namespace? probably that latter one
    tho it would be cool to give the config a coroutine factory providing coroutines which:
        get sent the sizes of ready-to-send messages
        return the number of additional bytes to wait for before sending, if we're not ready to send a chunk yet
        return 0 if we're ready to send as-is
        return a negative number if the message should be padded, with the absolute value indicating how many bytes of padding to add
        note: padding needs to be applied _before_ encryption, preventing the chunker logic from being broken out from the noise protocol
    the cool thing about doing it that way would be that it'd break up state appropriately btwn multiple Protocols fed from the same config

after all this is taken care of, we'll also need to fix how routing queries are handled, i bet, because currently the routing table doesn't maintain full contact info (tho maybe it should!) so it can't properly answer a query on its own

part of sorting out all the above config stuff also involves getting key generation right
    and to generate the keys properly, we're gonna have to know how they're gonna get used
    which is to say, how they'll be fed to the actual noise library object
    this is still sort of, shall we say, an "open question" since the library is light on documentation

another thing: down the road, once we have re-handshaking added to the noise wrapper, we should add some internal logic to make sure it re-handshakes prior to nonce exhaustion

maybe a good idea for how to start would be to write some Noise wrapper unit tests
    these vet the basic implementation and also offer a chance to get familiarized with how the library handles keys
    this in turn will inform our node key generation and handling
